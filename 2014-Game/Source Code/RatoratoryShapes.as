package {	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.ui.Keyboard;	import flash.media.Sound;	import flash.media.SoundMixer;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import Main;	//class declaration	public class RatoratoryShapes extends Object 	{		//declare variables		private var maps:Object;		private var doors:Object;		private var currentMap:Array;		private var complexTiles:Array;		private var animatedObjects:Array;		private var mapW:int;		private var mapH:int;		private var ts:int;		public static var myParent:MovieClip;		private var tilesBmp:Bitmap;		private var tSheet:BitmapData;		private var rat:Rat;				private var keys:Object;		private var goingThroughPortal:Boolean;		private var dontBuildMap:Boolean;		private var myBoolean:Boolean;		public var bgSoundChannel:SoundChannel = new SoundChannel();		protected var backgroundMusic:bgMusic;		public var muteKey:Boolean;		public static var isMuted:Boolean;		public var bgMusicState:Boolean;		var muteTransform:SoundTransform = new SoundTransform(0, 0);		var unmuteTransform:SoundTransform = new SoundTransform(1, 0);				//class constructor function		public function RatoratoryShapes (s:MovieClip) 		{			myParent = s;			prepareGame ();		}		//start the game by preparing stuff		private function prepareGame () 		{			myParent.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			ts = 32;			doors = new Object();			maps = new Object();			//we set new map data and call buildMap function			/*mapArray = [			[  0,  0,  0,  0,  0,  0,  0,  0],			[  0,101,101,101,101,101,101,  0],			[  0,101,  0,101,101,101,101,  0],			[  0,101,101,101,101,  0,101,  0],			[  0,101,101,101,101,101,102,  0],			[  0,  0,  0,  0,  0,  0,  0,  0]			];*/			/*maps.mapArray0=[		 [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,  0,  0,  0,  0,  0,  0,101,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,  0],         [  0,101,  0,101,101,101,101,  0,101,  0,  0,  0,  0,101,101,  0,  0,101,101,  0,  0,101,101,  0],         [  0,101,  0,101,101,101,101,  0,101,101,  0,101,101,101,101,101,  0,101,101,  0,101,101,101,  0],         [  0,101,  0,  0,  0,  0,  0,  0,101,101,  0,101,101,101,101,101,  0,101,  0,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,  0,101,101,101,101,101,  0,  0,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,  0,101,101,101,101,  0,  0,  0,  0,  0,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,  0,101,101,101,  0,  0,101,101,101,  0,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,  0,  0,  0,101,  0,101,101,101,101,  0,  0,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,  0,101,  0,101,101,101,101,101,  0,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,  0,101,  0,101,101,101,101,101,  0,101,101,  0],         [  0,101,101,101,101,101,  0,  0,  0,  0,  0,  0,101,101,  0,101,101,101,101,101,  0,101,101,  0],         [  0,101,101,101,101,101,  0,  0,101,101,101,101,101,101,  0,  0,  0,101,101,101,  0,101,101,  0],         [  0,101,101,101,101,101,101,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,101,  0,  0,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101],         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]		 ];*/		    maps.mapArray0=[ [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,101,101,101,101,101,101,101,119,  0,112,101,101,101,101,101,  0,105,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,  0,  0,  0,101,101,101,101,101,101,  0,101,101,101,101,101,  0],         [  0,  0,101,101,101,101,101,  0,107,  0,117,  0,101,101,101,101,101,101,  0,101,101,101,101,  0],         [  0,115,  0,101,101,101,  0,101,101,  0,101,101,  0,101,101,101,101,101,113,  0,104,  0,103,  0],         [  0,101,101,  0,102,  0,101,101,101,  0,101,101,101,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,101,101,112,  0,106,101,101,101,  0,101,101,101,116,  0,116,101,101,101,101,  0,109,101,  0],         [  0,101,101,  0,108,  0,101,101,101,  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,  0,101,  0],         [  0,101,101,  0,101,101,  0,101,101,  0,  0,101,101,101,  0,110,  0,101,101,101,  0,101,101,  0],         [  0,101,101,  0,101,101,101,  0,107,  0,122,101,  0,117,  0,101,101,  0,101,101,  0,101,101,  0],         [  0,101,  0,111,101,101,101,101,  0,  0,  0,  0,  0,  0,  0,101,101,101,  0,115,  0,101,101,  0],         [  0,101,111,  0,101,101,101,101,109,  0,119,101,101,101,  0,101,101,101,105,  0,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,101,  0,101,101,101,  0,104,  0,101,101,  0],         [  0,103,  0,102,  0,113,101,101,101,101,101,  0,101,101,  0,101,101,  0,101,101,101,  0,101,  0],         [  0,101,101,101,101,  0,101,101,101,101,101,101,  0,110,  0,108,  0,101,101,101,101,101,  0,  0],         [  0,101,101,101,101,101,  0,101,101,101,101,101,101,  0,  0,  0,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,106,  0,101,101,101,101,101,114,  0,114,101,101,101,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];			//blank array			/*[ [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];*/			//set up the doors			//doors["0_22_2"] = [0,2,2];// Target tile on new map should be next to the door.			doors["0_22_4"] = [0,1,14];			doors["0_1_13"] = [0,22,3];						doors["0_3_13"] = [0,4,4];			doors["0_4_5"] = [0,3,14];						doors["0_6_16"] = [0,6,6];			doors["0_5_6"] = [0,5,16];						doors["0_8_3"] = [0,8,8];			doors["0_8_9"] = [0,8,4];						doors["0_8_1"] = [0,11,11];			doors["0_10_11"] = [0,7,1];						doors["0_13_14"] = [0,15,9];			doors["0_15_8"] = [0,13,13];						doors["0_15_14"] = [0,4,8];			doors["0_4_7"] = [0,15,13];						doors["0_17_1"] = [0,17,11];			doors["0_18_11"] = [0,18,1];						doors["0_3_10"] = [0,1,11];			doors["0_2_11"] = [0,4,10];						doors["0_1_4"] = [0,19,9];			doors["0_19_10"] = [0,1,5];						doors["0_3_6"] = [0,11,1];			doors["0_10_1"] = [0,2,6];						doors["0_15_16"] = [0,12,16];			doors["0_13_16"] = [0,16,16];						doors["0_19_12"] = [0,20,3];			doors["0_20_4"] = [0,19,13];						doors["0_8_11"] = [0,22,6];			doors["0_21_6"] = [0,7,11];						doors["0_18_4"] = [0,6,13];			doors["0_5_13"] = [0,17,4];						doors["0_15_6"] = [0,12,6];			doors["0_13_6"] = [0,16,6];						doors["0_10_3"] = [0,13,8];			doors["0_13_9"] = [0,10,4];																		complexTiles = new Array();			complexTiles[102] = createComplexTile(1, [57,8,58,8,59,8,58,8]);			complexTiles[103] = createComplexTile(1, [3,9,4,9,5,9,4,9,]);			complexTiles[104] = createComplexTile(1, [6,10,7,10,8,10,7,10,]);			complexTiles[105] = createComplexTile(1, [9,11,10,11,11,11,10,11,]);			complexTiles[106] = createComplexTile(1, [12,12,13,12,14,12,13,12,]);			complexTiles[107] = createComplexTile(1, [15,13,16,13,17,13,16,13,]);			complexTiles[108] = createComplexTile(1, [18,14,19,14,20,14,19,14,]);			complexTiles[109] = createComplexTile(1, [21,15,22,15,23,15,22,15,]);			complexTiles[110] = createComplexTile(1, [24,16,25,16,26,16,25,16,]);			complexTiles[111] = createComplexTile(1, [27,8,28,8,29,8,28,8,]);			complexTiles[112] = createComplexTile(1, [30,9,31,9,32,9,31,9,]);			complexTiles[113] = createComplexTile(1, [33,10,34,10,35,10,34,10,]);			complexTiles[114] = createComplexTile(1, [36,11,37,11,38,11,37,11,]);			complexTiles[115] = createComplexTile(1, [39,12,40,12,41,12,40,12,]);			complexTiles[116] = createComplexTile(1, [42,13,43,13,44,13,43,13,]);			complexTiles[117] = createComplexTile(1, [45,14,46,14,47,14,46,14,]);			complexTiles[118] = createComplexTile(1, [48,15,49,15,50,15,49,15,]);			complexTiles[119] = createComplexTile(1, [51,16,52,16,53,16,52,16,]);			complexTiles[120] = createComplexTile(1, [54,8,55,8,56,8,55,8,]);			complexTiles[122] = createComplexTile(1, [2]);						//set up array for all animated things			animatedObjects = new Array();			//get the tilesheet			tSheet = new RatTileSheet(0,0);			//set up current map array			//currentMap = mapArray;			//add new rat instance			rat = new Rat(0, 24, 22, 1);			rat.speed = 4;			rat.moveOb = new Object();			rat.mymap = 0;			//add rat to animations			animatedObjects.push(rat);						//set up keys object			keys = new Object();			//fill the object with arrow keys			keys[Keyboard.UP] = {down :false, dirx:0, diry:-1, sprNum:1, anim:[1,6,5,6,1,6,9,6]};			keys[Keyboard.DOWN] = {down:false, dirx:0, diry:1, sprNum:0, anim:[0,6,4,6,0,6,8,6]};			keys[Keyboard.LEFT] = {down:false, dirx:-1, diry:0, sprNum:3, anim:[3,6,7,6,3,6,11,6]};			keys[Keyboard.RIGHT] = {down:false, dirx:1, diry:0, sprNum:2, anim:[2,6,6,6,2,6,10,6]};												//create map			buildMap ();			//add key listeners to tilesclip			myParent.addEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.addEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.addEventListener (Event.ENTER_FRAME, runGame);			//hide ugly yellow rectangle around objects			myParent.stage.stageFocusRect = false;			bgMusicState = true;			playBgMusic();			isMuted = false;		}		public function playBgMusic()		{			trace("inside function");			if (bgMusicState == true)				{					trace("bgmusicstate=true");					bgMusicState = false;					backgroundMusic=new bgMusic;					bgSoundChannel = backgroundMusic.play(0, 99);									}				else // turn sound off				{					trace("bgmusic state = false");					bgSoundChannel.stop();				}										}function keyDownHandler(k:KeyboardEvent):void		{						if (k.keyCode == 77)			{				if (muteKey == false)				{					muteKey = true;					trace("muted");					isMuted = true;					bgSoundChannel.soundTransform = muteTransform;													}				else 				{					muteKey = false;					trace("unmuted");					isMuted = false;					bgSoundChannel.soundTransform = unmuteTransform;									}			}		}		//build new map		private function buildMap () 		{			//get map dimensions			currentMap = maps["mapArray" + rat.mymap];			mapW = currentMap[0].length;			mapH = currentMap.length;			//main bitmap to be shown on screen			if (tilesBmp!=null)			{				myParent.removeChild(tilesBmp);											}			tilesBmp = new Bitmap(new BitmapData(ts * mapW, ts * mapH));			//add this clip to stage			myParent.addChild (tilesBmp);			//loop to place tiles on stage			for (var yt:int = 0; yt < mapH; yt++) 			{				for (var xt:int = 0; xt < mapW; xt++) 				{					var s:int = currentMap[yt][xt];					//check for complex tile type					var cT:Object = complexTiles[s];					if (cT != null) 					{						//draw one image						drawTile (cT.baseSpr, xt, yt);						//check for animated image						if(cT.anim.length > 1){							var ob:Object = new Object();							ob.anim = cT.anim;							ob.baseSpr = cT.baseSpr;							//reset animation counters							ob.animCount = 0;							ob.animTime = 0;							ob.xt = xt;							ob.yt = yt;							//add to animated objects array							animatedObjects.push(ob);						}else						{							//second image to be drawn later							s = cT.anim[0];						}						//second image to be drawn later						s = cT.anim[0];					}else if (s >= 100) 					{						s = s - 100;					}					//put image on screen					drawTile (s, xt, yt);				}			}			//add graphics to rat			if (rat.bmp != null)			{				myParent.removeChild(rat.bmp);			}			rat.bmp = getImageFromSheet (rat.sprNum, rat);			moveObject (rat);			//add rat to the screen						myParent.addChild (rat.bmp);						//reset keys			for each (var keyOb in keys)			{				keyOb.down = false;			}		}		//this is main game function that is run at enterframe event		private function runGame (ev:Event):void 		{			var moveOb:Object = new Object();						//find if any movement key is down			for each (var keyOb in keys) 			{				if(keyOb.down == false)				{						if (rat.sprNum == 0)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 0;							moveOb.anim = [];						}						else if (rat.sprNum==4)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 0;							moveOb.anim = [];						}						else if (rat.sprNum==8)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 0;							moveOb.anim = [];						}						else if (rat.sprNum == 1)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 1;							moveOb.anim = [];						}						else if (rat.sprNum==5)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 1;							moveOb.anim = [];						}						else if (rat.sprNum==9)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 1;							moveOb.anim = [];						}						else if (rat.sprNum == 2)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 2;							moveOb.anim = [];						}						else if (rat.sprNum==6)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 2;							moveOb.anim = [];						}						else if (rat.sprNum==10)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 2;							moveOb.anim = [];						}						else if (rat.sprNum == 3)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 3;							moveOb.anim = [];						}						else if (rat.sprNum==7)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 3;							moveOb.anim = [];						}						else if (rat.sprNum==11)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 3;							moveOb.anim = [];						}										}				//yep, arrow key is down				else if (keyOb.down == true) 				{					//check if tile is walkable					if (getMyCorners(rat.x + keyOb.dirx * rat.speed, rat.y + keyOb.diry * rat.speed, rat) == true) 					{						moveOb = keyOb;						moveOb.anim= keyOb.anim;					}else					{						//we have hit the wall, place near it						if(keyOb.dirx < 0)						{							rat.x = rat.xtile * ts;						}else if(keyOb.dirx > 0)						{							rat.xtile = Math.floor((rat.x + rat.speed) / ts);							rat.x = (rat.xtile + 1) * ts - rat.ts;						}else if(keyOb.diry < 0)						{							rat.y = rat.ytile * ts;						}else if(keyOb.diry > 0)						{							rat.ytile = Math.floor((rat.y + rat.speed) / ts);							rat.y = (rat.ytile + 1) * ts - rat.ts;						}						moveOb.dirx = 0;						moveOb.diry = 0;						moveOb.sprNum = keyOb.sprNum;						moveOb.anim = [];						//try to move rat around the wall tiles						if(keyOb.dirx != 0)						{							var ytc:int = Math.floor((rat.y + rat.ts/2) / ts);							if(isWalkable(rat.xtile + keyOb.dirx, ytc))							{								//align vertically								var centerY:int = ytc * ts + (ts - rat.ts) / 2;								if(rat.y > centerY)								{									//move up									rat.y--;									moveOb.anim = keyOb.anim;								}else if(rat.y < centerY)								{									//move down									rat.y++;									moveOb.anim = keyOb.anim;								}							}						}else						{							var xtc:int = Math.floor((rat.x + rat.ts/2) / ts);							if(isWalkable(xtc, rat.ytile + keyOb.diry))							{								//align horisontal								var centerX:int = xtc * ts + (ts - rat.ts) / 2;								if(rat.x > centerX)								{									//move left									rat.x--;									moveOb.anim = keyOb.anim;								}else if(rat.x < centerX)								{									rat.x++;									moveOb.anim = keyOb.anim;								}							}						}					}					break;				}							}			if(moveOb.dirx != null)			{				//move the rat				moveObject (rat, moveOb);			}else			{				rat.anim = [];			}			//animate the objects				animateSprite ();			//get the focus to the main clip to keys are detected			if (myParent.stage.focus != myParent) 			{				myParent.stage.focus = myParent;			}						if(isTeleporter(rat.xtile, rat.ytile))			   {				  cleanUp();				 myParent.level4Available=true;				  myParent.gotoAndStop("levelselect");			   }								}		private function cleanUp()		{			myParent.removeEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.removeEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.removeEventListener (Event.ENTER_FRAME, runGame);			bgMusicState=false;			playBgMusic();			myParent.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			myParent.removeChild(tilesBmp);			myParent.removeChild(rat.bmp);		}		private function isTeleporter (xt:int, yt:int):Boolean 		{			if(currentMap[yt][xt] == 122)			{				return true;			}else			{				return false;			}					}				//this function will finds if tile is walkable		private function isWalkable (xt:int, yt:int):Boolean 		{			if(currentMap[yt][xt] >= 100)			{				return true;			}else			{				return false;			}		}		//this function will detect keys that are being pressed		private function downKeys (ev:KeyboardEvent):void 		{			//check if the is arrow key			if (keys[ev.keyCode] != undefined) 			{				//set the key to true				keys[ev.keyCode].down = true;			}		}		//this function will detect keys that are being released		private function upKeys (ev:KeyboardEvent):void 		{			//check if the is arrow key			if (keys[ev.keyCode] != undefined) 			{				//set the key to false				keys[ev.keyCode].down = false;							}		}		//this function will move object		private function moveObject (ob:*, moveOb:* = null):void {			if(moveOb != null){				ob.x += moveOb.dirx * ob.speed;				ob.y += moveOb.diry * ob.speed;				//check if graphics need to change				if (ob.moveOb != moveOb) 				{					//change sprite					ob.moveOb = moveOb;					ob.sprNum = moveOb.sprNum;					ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;					if(ob.anim != moveOb.anim)					{						ob.animTime = 0;						ob.animCount = 0;						ob.anim = moveOb.anim;					}				}			}else			{				//find new coordinates				ob.x = ob.xtile * ts + (ts - ob.ts) / 2;				ob.y = ob.ytile * ts + (ts - ob.ts) / 2;			}			//update tile			ob.xtile = Math.floor(ob.x / ts);			ob.ytile = Math.floor(ob.y / ts);			//place the graphics			ob.bmp.x = ob.x;			ob.bmp.y = ob.y;			checkDoor (ob);		}		//this function will check for door		private function checkDoor (ob:*):void 		{			//center tile			var ytc:int = Math.floor((ob.y + ob.ts/2) / ts);			var xtc:int = Math.floor((ob.x + ob.ts/2) / ts);			var tileName:String = ob.mymap + "_" + xtc + "_" + ytc;			//check if door exist			if (doors[tileName] != null) 			{				//change map													ob.mymap = doors[tileName][0];					ob.xtile = doors[tileName][1];					ob.ytile = doors[tileName][2];										animatedObjects.splice(1,animatedObjects.length-1);					buildMap();																									}		}		private function getMyCorners (x:Number, y:Number, ob:Object):Boolean 		{			//find corner points			var upY:Number = Math.floor(y / ts);			var downY:Number = Math.floor((y + ob.ts - 1) / ts);			var leftX:Number = Math.floor(x / ts);			var rightX:Number = Math.floor((x + ob.ts - 1) / ts);			if (upY < 0 || downY >= mapH || leftX < 0 || rightX >= mapW) 			{				return false;			}			//check if they are walls			var ul:Boolean = isWalkable (leftX, upY);			var dl:Boolean = isWalkable (leftX, downY);			var ur:Boolean = isWalkable (rightX, upY);			var dr:Boolean = isWalkable (rightX, downY);			return ul && dl && ur && dr;		}		//this function will animate all the objects		private function animateSprite ():void 		{			//run through all objects needing the animation			for (var n:int = 0; n < animatedObjects.length; n++) 			{				var ob:Object = animatedObjects[n];				if(ob.anim.length > 0)				{					//add 1 to time counter					ob.animTime++;					var reachedEnd:Boolean = false;					//check if the time has counted up					if(ob.animTime == ob.anim[ob.animCount + 1])					{						//add to current image counter						ob.animCount += 2;						//check if end of animation is reached						if(ob.animCount == ob.anim.length)						{							//reset to start							ob.animCount = 0;						}						//check if its tile or separate object like rat						if(ob.bmp == null)						{							//clear the current tile image							var rect:Rectangle = new Rectangle(ob.xt * ts, ob.yt * ts, ts, ts);							tilesBmp.bitmapData.fillRect (rect, 0x00000000);							//change the image if time is right							ob.s = ob.anim[ob.animCount];							drawTile (ob.baseSpr, ob.xt, ob.yt);							drawTile (ob.s, ob.xt, ob.yt);							if (goingThroughPortal== true)							{								myParent.removeChild(ob.bmp);							}													}else						{							//its rat							ob.sprNum = ob.anim[ob.animCount];							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						//reset animation timer						ob.animTime = 0;					}				}			}		}		//this function gets image from tilesheet		private function getImageFromSheet (s:Number, ob:* = null):Bitmap 		{			var tsize:int = ts;			var sheet:BitmapData = tSheet;			if(ob != null)			{				tsize = ob.ts;				sheet = ob.sheet;			}			//number of columns in tilesheet			var sheetColumns:int = tSheet.width / tsize;			//position where to take graphics from			var col:int = s % sheetColumns;			var row:int = Math.floor(s / sheetColumns);			//rectangle that defines tile graphics			var rect:Rectangle = new Rectangle(col * tsize, row * tsize, tsize, tsize);			var pt:Point = new Point(0, 0);			//get the tile graphics from tilesheet			var bmp:Bitmap =  new Bitmap(new BitmapData(tsize, tsize, true, 0));			bmp.bitmapData.copyPixels (sheet, rect, pt, null, null, true);			return bmp;		}		private function drawTile (s:Number, xt:int, yt:int):void 		{			var bmp:Bitmap = getImageFromSheet (s);			//rectangle has size of tile and it starts from 0,0			var rect:Rectangle = new Rectangle(0, 0, ts, ts);			//point on screen where the tile goes			var pt:Point = new Point(xt * ts, yt * ts);			//copy tile bitmap to main bitmap			tilesBmp.bitmapData.copyPixels (bmp.bitmapData, rect, pt, null, null, true);		}		private function createComplexTile (spr1:int, animArr:Array, st:String = ""):Object		{			//create new object			var ob:Object = new Object();			//base graphics, will always remain same			ob.baseSpr = spr1;			//array of animation graphics			ob.anim = animArr;			//tile could be some special type			ob.specialType = st;			return ob;		}	}}