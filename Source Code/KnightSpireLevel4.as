package {	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.ui.Keyboard;	import flash.media.Sound;	import flash.media.SoundMixer;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import Main;	//class declaration	public class KnightSpireLevel4 extends Object 	{		//declare variables		private var maps:Object;		private var doors:Object;		private var currentMap:Array;		private var complexTiles:Array;		private var animatedObjects:Array;		private var mapW:int;		private var mapH:int;		private var ts:int;		private var myParent:MovieClip;		private var tilesBmp:Bitmap;		private var tSheet:BitmapData;		private var hero:Hero;		private var keys:Object;		private var goingThroughPortal:Boolean;		private var dontBuildMap:Boolean;		private var myBoolean:Boolean;		public var stageW2:Number;// = stage.stageWidth/2;		public var stageH2:Number; //= stage.stageHeight/2;		public var view:Rectangle;// = new Rectangle(0,0,stage.stageWidth,stage.stageHeight);		public var mapWidth:Number;		public var mapHeight:Number;		public var ableToJump:Boolean;		public var isJumping:Boolean;		public var onWall:Boolean;		public var fallingDown:Boolean;		public var onLeftWall:Boolean;		public var onRightWall:Boolean;		public var hasBeenJumping:Boolean;		public var heroMap:int;		public var heroFallenUp:Boolean;		public var heroMaxY:Number;		public var bgSoundChannel:SoundChannel = new SoundChannel();		protected var backgroundMusic:bgMusicKnight;		public var muteKey:Boolean;		public static var isMuted:Boolean;		public var bgMusicState:Boolean;		var muteTransform:SoundTransform = new SoundTransform(0, 0);		var unmuteTransform:SoundTransform = new SoundTransform(1, 0);						//class constructor function		public function KnightSpireLevel4 (s:MovieClip) 		{			myParent = s;			prepareGame ();			heroMap=0;		}		//start the game by preparing stuff		private function prepareGame () 		{			myParent.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			stageW2=myParent.width/2;			stageH2=myParent.height/2;						view = new Rectangle(0,0,myParent.width,myParent.height);			ts = 32;			doors = new Object();			maps = new Object();			//we set new map data and call buildMap function						maps.mapArray0 = [  		 [  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,150,151,101,101,101,101,101,101,101,  0,142,101,101,101,101,101,141,  0,101,101,101,101,  0],         [  0,152,153,101,101,101,101,101,101,101,101,  0,140,  0,101,101,101,141,  0,101,101,  0,103,  0],         [  0,  0,  0,  0,  0,140,  0,140,  0,  0,101,101,  0,  0,  0,  0,103,  0,101,101,101,  0,101,  0],		 [  0,105,101,101,101,  0,101,  0,101,101,  0,103,  0,101,101,101,101,  0,101,101,101,  0,103,  0],         [  0,  1,101,101,101,101,101,101,101,101,  0,101,101,101,101,101,103,101,101,101,101,  0,101,  0],         [  0,104,  0,101,101,101,101,101,101,101,  0,  0,103,  0,101,101,101,101,101,  0,101,  0,103,  0],         [  0,104,101,101,101,101,101,101,105,101,101,101,101,101,140,140,  0,101,101,101,140,  0,101,  0],         [  0,104,101,101,  0,101,101,101,  1,  0,101,101,101,101,  0,  0,101,140,  0,140,  0,  0,103,  0],         [  0,104,101,101,101,101,101,101,104,141,  0,101,101,101,101,101,101,  0,101,  0,142,101,101,  0],         [  0,104,101,101,101,101,101,101,104,141,  0,101,101,101,101,101,101,101,101,  0,142,101,103,  0],         [  0,104,  0,101,101,  0,101,101,  0,  0,101,101,101,101,101,105,101,101,101,101,  0,103,  0,  0],         [  0,104,101,101,101,101,101,101,101,101,101,101,101,101,101,  1,101,101,101,101,101,101,101,  0],         [  0,104,101,101,101,101,101,101,101,101,101,101,101,101,101,104,101,101,101,101,101,  0,101,  0],         [  0,104,101,  0,101,101,101,  0,101,  0,101,101,101,  0,  0,  0,101,101,101,101,  0,101,101,  0],         [  0,  0,101,141,  0,101,101,101,101,101,101,101,101,101,101,101,101,101,  0,101,101,101,101,  0],         [  0,101,101,141,  0,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,  0],       	 [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];		 maps.mapArray1 = [ 		 [  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,150,151,101,101,101,101,101,101,101,  0,142,101,101,101,101,101,141,  0,101,101,101,101,  0],         [  0,152,153,101,101,101,101,101,101,101,101,  0,140,  0,101,101,101,141,  0,101,101,  0,103,  0],         [  0,  0,  0,  0,  0,140,  0,140,  0,  0,101,101,  0,  0,  0,  0,103,  0,101,101,101,  0,101,  0],		 [  0,105,101,101,101,  0,101,  0,101,101,  0,103,  0,101,101,101,101,  0,101,101,101,  0,103,  0],         [  0,  1,101,101,101,101,101,101,101,101,  0,101,101,101,101,101,103,101,101,101,101,  0,101,  0],         [  0,104,  0,101,101,101,101,101,101,101,  0,  0,103,  0,101,101,101,101,101,  0,101,  0,103,  0],         [  0,104,101,101,101,101,101,101,105,101,101,101,101,101,140,140,  0,101,101,101,140,  0,101,  0],         [  0,104,101,101,  0,101,101,101,  1,  0,101,101,101,101,  0,  0,101,140,  0,140,  0,  0,103,  0],         [  0,104,101,101,101,101,101,101,104,141,  0,101,101,101,101,101,101,  0,101,  0,142,101,101,  0],         [  0,104,101,101,101,101,101,101,104,141,  0,101,101,101,101,101,101,101,101,  0,142,101,103,  0],         [  0,104,  0,101,101,  0,101,101,  0,  0,101,101,101,101,101,105,101,101,101,101,  0,103,  0,  0],         [  0,104,101,101,101,101,101,101,101,101,101,101,101,101,101,  1,101,101,101,101,101,101,101,  0],         [  0,104,101,101,101,101,101,101,101,101,101,101,101,101,101,104,101,101,101,101,101,  0,101,  0],         [  0,104,101,  0,101,101,101,  0,101,  0,101,101,101,  0,  0,  0,101,101,101,101,  0,101,101,  0],         [  0,  0,101,141,  0,101,101,101,101,101,101,101,101,101,101,101,101,101,  0,101,101,101,101,  0],         [  0,101,101,141,  0,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,  0],       	 [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];		 maps.mapArray2 = [ 		 [  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,150,151,101,101,101,101,101,101,101,  0,142,101,101,101,101,101,141,  0,101,101,101,101,  0],         [  0,152,153,101,101,101,101,101,101,101,101,  0,140,  0,101,101,101,141,  0,101,101,  0,103,  0],         [  0,  0,  0,  0,  0,140,  0,140,  0,  0,101,101,  0,  0,  0,  0,103,  0,101,101,101,  0,101,  0],		 [  0,105,101,101,101,  0,101,  0,101,101,  0,103,  0,101,101,101,101,  0,101,101,101,  0,103,  0],         [  0,  1,101,101,101,101,101,101,101,101,  0,101,101,101,101,101,103,101,101,101,101,  0,101,  0],         [  0,104,  0,101,101,101,101,101,101,101,  0,  0,103,  0,101,101,101,101,101,  0,101,  0,103,  0],         [  0,104,101,101,101,101,101,101,105,101,101,101,101,101,140,140,  0,101,101,101,140,  0,101,  0],         [  0,104,101,101,  0,101,101,101,  1,  0,101,101,101,101,  0,  0,101,140,  0,140,  0,  0,103,  0],         [  0,104,101,101,101,101,101,101,104,141,  0,101,101,101,101,101,101,  0,101,  0,142,101,101,  0],         [  0,104,101,101,101,101,101,101,104,141,  0,101,101,101,101,101,101,101,101,  0,142,101,103,  0],         [  0,104,  0,101,101,  0,101,101,  0,  0,101,101,101,101,101,105,101,101,101,101,  0,103,  0,  0],         [  0,104,101,101,101,101,101,101,101,101,101,101,101,101,101,  1,101,101,101,101,101,101,101,  0],         [  0,104,101,101,101,101,101,101,101,101,101,101,101,101,101,104,101,101,101,101,101,  0,101,  0],         [  0,104,101,  0,101,101,101,  0,101,  0,101,101,101,  0,  0,  0,101,101,101,101,  0,101,101,  0],         [  0,  0,101,141,  0,101,101,101,101,101,101,101,101,101,101,101,101,101,  0,101,101,101,101,  0],         [  0,101,101,141,  0,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,  0],       	 [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];						//blank array			/*[ 		 [  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,  0,  0,  0,  0,  0,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,101,101,101,  0,  0,  0,  0, 20,101,101, 21,  0],         [  0,  0,  0,  0,  0,  0,101,101,101,101,140,140,101,101,101,  0,101,101,101, 20,101,101, 21,  0],         [  0,  0,  0,  0,  0,101,101,101,  0,  0,  0,  0,  0,  0,101,101,101,101,101, 20,101,101, 21,  0],         [  0,  0,  0,  0,101,101,101,  0,  0,101,101,101,101,  0,101,101,101,101,101, 20,101,101, 21,  0],         [  0,101,101,101,101,103,  0,  0,101,101,  0,  0,105,101,  0,  0,  0,  0,  0, 20,101,101, 21,101],         [  0,101,101,101,101,101,101,101,101,  0,  0,  0,  1,101,101,101,101,101,101, 20,101,101,101,101],         [  0,  0,  0,  0,101,101,  0,101,101,101,101,101,  1,101,103,103,103,  0,  0, 20,101,101,101,  0],         [  0,  0,  0,  0,  0,101,101,  0,  0,  0,101,101,  1,101,101,101,101,101,101,101,101,101,  0,  0],         [  0,  0,  0,  0,  0,  0,101,101,101,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,104,  0,  0,101,101,101,101,101,  0,  0,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,101,101,  0,  0,  0,  0,  0,101,101,  0,  0,101,  0,  0,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,  0,  0,101,  0,  0,101,101,  0,  0,101,  0,  0,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];*/			/*[ [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  0],         [  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0] ];*/			//set up the doors			//doors["0_22_2"] = [0,2,2];// Target tile on new map should be next to the door.			/*doors["0_23_8"] = [1,0,8];			doors["0_23_9"] = [1,0,9];			doors["1_15_1"] = [1,14,3];			doors["1_15_3"] = [1,16,1];						doors["1_15_14"] = [1,11,11];			doors["1_10_11"] = [1,14,14];*/															complexTiles = new Array();			complexTiles[110] = createComplexTile(1, [2]);//[51,16,52,16,53,16,52,16,]);			complexTiles[111] = createComplexTile(0, [2]);			complexTiles[1] = createComplexTile(0, [4], "ladder");			complexTiles[20] = createComplexTile(0, [7], "jumpWall");			complexTiles[21] = createComplexTile(0, [6], "jumpWall");			complexTiles[103] = createComplexTile(1, [3], "cloud");			complexTiles[104] = createComplexTile(1, [4], "ladder");			complexTiles[105] = createComplexTile(1, [5], "ladder");			complexTiles[140] = createComplexTile(1, [2], "spike");			complexTiles[141] = createComplexTile(1, [11], "spike");			complexTiles[142] = createComplexTile(1, [14], "spike");			complexTiles[2] = createComplexTile(0, [8]);			complexTiles[150]=createComplexTile(1, [9]);			complexTiles[151]=createComplexTile(1, [10]);			complexTiles[152]=createComplexTile(1, [12], "DOOR");			complexTiles[153]=createComplexTile(1, [13], "DOOR");									//set up array for all animated things			animatedObjects = new Array();			//get the tilesheet			tSheet = new TileSheet(0,0);			//set up current map array			//currentMap = mapArray;			//add new hero instance			hero = new Hero(0, 24, 1,16);			hero.speed = 3;			hero.jumpStart = -12;			hero.gravity = 1;			hero.moveOb = new Object();			hero.mymap = heroMap;			//add hero to animations			animatedObjects.push(hero);			//set up keys object			keys = new Object();			//fill the object with arrow keys			keys[Keyboard.UP] = {down :false, dirx:0, diry:-1, sprNum:1, anim:[1,6,5,6,1,6,9,6]};			keys[Keyboard.DOWN] = {down:false, dirx:0, diry:1, sprNum:0, anim:[0,6,4,6,0,6,8,6]};			keys[Keyboard.LEFT] = {down:false, dirx:-1, diry:0, sprNum:3, anim:[3,6,7,6,3,6,11,6]};			keys[Keyboard.RIGHT] = {down:false, dirx:1, diry:0, sprNum:2, anim:[2,6,6,6,2,6,10,6]};												//create map			buildMap ();			//add key listeners to tilesclip			myParent.addEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.addEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.addEventListener (Event.ENTER_FRAME, runGame);			bgMusicState = true;			playBgMusic();			isMuted = false;			//hide ugly yellow rectangle around objects			myParent.stage.stageFocusRect = false;		}		//build new map		private function buildMap () 		{			//get map dimensions			currentMap = maps["mapArray" + hero.mymap];			mapW = currentMap[0].length;			mapH = currentMap.length;			//main bitmap to be shown on screen			if (tilesBmp!=null)			{				myParent.removeChild(tilesBmp);											}			tilesBmp = new Bitmap(new BitmapData(ts * mapW, ts * mapH));			//add this clip to stage			myParent.addChild (tilesBmp);						//loop to place tiles on stage			for (var yt:int = 0; yt < mapH; yt++) 			{				for (var xt:int = 0; xt < mapW; xt++) 				{					var s:int = currentMap[yt][xt];					//check for complex tile type					var cT:Object = complexTiles[s];					if (cT != null) 					{						//draw one image						drawTile (cT.baseSpr, xt, yt);						//check for animated image						if(cT.anim.length > 1){							var ob:Object = new Object();							ob.anim = cT.anim;							ob.baseSpr = cT.baseSpr;							//reset animation counters							ob.animCount = 0;							ob.animTime = 0;							ob.xt = xt;							ob.yt = yt;							//add to animated objects array							animatedObjects.push(ob);						}else						{							//second image to be drawn later							s = cT.anim[0];						}						//second image to be drawn later						s = cT.anim[0];					}else if (s >= 100) 					{						s = s - 100;					}					//put image on screen					drawTile (s, xt, yt);				}			}			mapHeight=mapH*ts;			mapWidth=mapH*ts;			//add graphics to hero			if (hero.bmp != null)			{				myParent.removeChild(hero.bmp);			}			hero.bmp = getImageFromSheet (hero.sprNum, hero);			moveObject (hero);			//add hero to the screen						myParent.addChild (hero.bmp);			/*tilesBmp.x=-hero.bmp.x+(myParent.width/2);			tilesBmp.y=-hero.bmp.y+(myParent.height/2);*/			//reset keys			for each (var keyOb in keys)			{				keyOb.down = false;			}		}		private function isCloud (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt];			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "cloud")				{					return true;				}			}			return false;		}		private function isLeftJumpWall (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt-1];			//trace(s);			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "jumpWall")				{					return true;				}				else				{					return false;				}			}			return false;		}		public function playBgMusic()		{			trace("inside function");			if (bgMusicState == true)				{					trace("bgmusicstate=true");					bgMusicState = false;					backgroundMusic=new bgMusicKnight;					bgSoundChannel = backgroundMusic.play(0, 99);									}				else // turn sound off				{					trace("bgmusic state = false");					bgSoundChannel.stop();				}										}		function keyDownHandler(k:KeyboardEvent):void		{						if (k.keyCode == 77)			{				if (muteKey == false)				{					muteKey = true;					trace("muted");					isMuted = true;					bgSoundChannel.soundTransform = muteTransform;													}				else 				{					muteKey = false;					trace("unmuted");					isMuted = false;					bgSoundChannel.soundTransform = unmuteTransform;									}			}		}		private function isRightJumpWall (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt+1];			//trace(s);			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "jumpWall")				{					return true;				}				else				{					return false;				}			}			return false;		}		//this function will align hero on the ladder		private function alignToLadder (ob:*):void {			//center hero horisontally			var dx:int = ob.x - (ob.xtc * ts + (ts - ob.ts) / 2);			if(Math.abs(dx) < ob.speed){				var sp:int = Math.abs(dx);			}else{				sp = ob.speed;			}			if(dx < 0){				ob.x += sp;			}else if(dx > 0){				ob.x -= sp;			}		}		//this is main game function that is run at enterframe event		private function runGame (ev:Event):void 		{			//find if any movement key is down			for each (var keyOb in keys) 			{								//yep, arrow key is down				if (keyOb.down == true && keyOb.dirx != 0) 				{										if(getMyCorners(hero.x, hero.y, hero) == true)					{						//check if tile is walkable						if (getMyCorners(hero.x + keyOb.dirx * hero.speed, hero.y, hero) == false) 						{														//we have hit the wall, place near it							if(keyOb.dirx < 0)							{																hero.x = hero.xtile * ts;								isJumping=false;								onWall=true;								if (onWall == true && fallingDown==true)								{									if (getMyCornersForJumpWall(hero.x, hero.y, hero) == true)									{																			if(isLeftJumpWall (hero.xtile, hero.ytile) == true && keys[Keyboard.LEFT].down == true)										{											//let the hero jump again											onLeftWall=true;											onRightWall=false;											hero.gravity=.98;											hero.jumpSpeed=Infinity;										}																													} 									else									{										keys[Keyboard.LEFT].down=false;										onWall=false;										onLeftWall=false;										hero.gravity=1;									}										//hero.jumpSpeed=Infinity;																												}								else								{									onWall=false;									onLeftWall=false;									hero.gravity=1;									//hero.jumpSpeed=hero.jumpSpeed;								}																				}else							{								hero.xtile = Math.floor((hero.x + hero.speed) / ts);								hero.x = (hero.xtile + 1) * ts - hero.ts;								isJumping=false;								onWall=true;								if (onWall == true && fallingDown==true)								{									if (getMyCornersForJumpWall(hero.x, hero.y, hero) == true)									{										if(isRightJumpWall (hero.xtile, hero.ytile) == true && keys[Keyboard.RIGHT].down == true)										{											//let the hero jump again											onRightWall=true;											onLeftWall=false;											hero.gravity=.98;											hero.jumpSpeed=Infinity;										}																			}									else									{										keys[Keyboard.RIGHT].down=false;										onWall=false;										onRightWall=false;										hero.gravity=1;									}																																											}								else								{																		onWall=false;									onRightWall=false;									hero.gravity=1;									//hero.jumpSpeed=hero.jumpSpeed;								}							}							moveObject (hero, {dirx:0, diry:0, sprNum:keyOb.sprNum});						}else						{							hero.onLadder = false;							isJumping=false;							onWall=false;							if (onWall == true && fallingDown==true)								{									//let the hero jump again									hero.gravity=.98;									hero.jumpSpeed=Infinity;																	}								else if (keys[Keyboard.LEFT].down == false && keys[Keyboard.RIGHT].down == false)								{									onLeftWall=false;									onRightWall=false;									onWall=false;																		hero.gravity=1;									//hero.jumpSpeed=hero.jumpSpeed;								}														//moveOb = keyOb;							moveObject (hero, keyOb);													}					}					else					{						onWall=false;						onLeftWall=false;						onRightWall=false;						hero.gravity=1;					}										break;				}			}									//check for ladder			if(isLadder (hero.xtc, hero.ytc) == true)			{				//up key is pressed				if (keys[Keyboard.UP].down == true) 				{					//tile where downmost point of hero is located + 1					var downTile:int = Math.floor((hero.y + hero.ts - 1) / ts);					//must have ladder tile above					if(isLadder (hero.xtc, downTile - 1))					{						//align horisontally						alignToLadder (hero);						//climb up						moveObject (hero, keys[Keyboard.UP]);						//set on the ladder						hero.onLadder = true;						//recalculate downmost tile						downTile = Math.floor((hero.y + hero.ts) / ts);						if(isLadder (hero.xtc, downTile - 1) == false)						{							//if can not climb up anymore, set to the standing on tile below							hero.y = (hero.ytile + 1) * ts - hero.ts;							moveObject (hero, {dirx:0, diry:0, sprNum:hero.sprNum});						}					}				}else if (keys[Keyboard.DOWN].down == true) 				{					//tile where downmost point of hero is located + 1					downTile = Math.floor((hero.y + hero.ts) / ts);					//must be currently on ladder tile					if(isLadder (hero.xtc, downTile) == true)					{						//align horisontally						alignToLadder (hero);						//climb down						moveObject (hero, keys[Keyboard.DOWN]);						//set on the ladder						hero.onLadder = true;						//recalculate downmost tile						downTile = Math.floor((hero.y + hero.ts) / ts);						if(isLadder (hero.xtc, downTile) == false)						{							//if can not climb down anymore, set to the standing on tile below							hero.y = (hero.ytile + 1) * ts - hero.ts;							moveObject (hero, {dirx:0, diry:0, sprNum:hero.sprNum});						}					}				}			}						//currently not jumping			if (hero.jumpSpeed == Infinity && hero.onLadder == false) 			{								isJumping=false;				//jump started				if (keys[Keyboard.UP].down == true) 				{					keys[Keyboard.UP].down = false;					if (keys[Keyboard.LEFT].down==true || hero.sprNum==3)					{						hero.sprNum=12;					}					else if (keys[Keyboard.RIGHT].down==true || hero.sprNum==2)					{						hero.sprNum=13;					}										if (onRightWall==true && onWall==true && fallingDown==true && hero.gravity<1 && hasBeenJumping==false)					{						trace("yoo");																		if(isRightJumpWall (hero.xtile, hero.ytile) == false && isLeftJumpWall (hero.xtile, hero.ytile) == false)						{							keys[Keyboard.LEFT].down=false;							keys[Keyboard.RIGHT].down=false;																				}						else 						{														keys[Keyboard.LEFT].down=true;							keys[Keyboard.RIGHT].down=false;						}						hero.jumpSpeed = hero.jumpStart						hasBeenJumping=true;						onRightWall=false;						onLeftWall=true;					}					else 					{						hero.jumpSpeed = hero.jumpStart;						/*trace(onRightWall);						trace(onWall);						trace(fallingDown);						trace(hero.gravity);						trace(hasBeenJumping);*/						hasBeenJumping=false;					}					/*else					{						trace(onRightWall);						trace(onWall);						trace(fallingDown);						trace(hero.gravity);						trace(hasBeenJumping);					}*/					//bugfix?					if (onLeftWall==true && onWall==true && fallingDown==true && hero.gravity<1 && hasBeenJumping==false)					{																		if(isRightJumpWall (hero.xtile, hero.ytile) == false && isLeftJumpWall (hero.xtile, hero.ytile) == false)						{							keys[Keyboard.RIGHT].down=false;							keys[Keyboard.LEFT].down=false;																				}						else 						{							keys[Keyboard.RIGHT].down=true;							keys[Keyboard.LEFT].down=false;						}						hero.jumpSpeed = hero.jumpStart						hasBeenJumping=true;						onLeftWall=false;						onRightWall=true;					}					else 					{						trace(onLeftWall);						trace(onWall);						trace(fallingDown);						trace(hero.gravity);						trace(hasBeenJumping);						hero.jumpSpeed = hero.jumpStart;						hasBeenJumping=false;					}														} else if (getMyCorners(hero.x, hero.y + 1, hero) == true) 				{					//if both tiles below are walkable, we will fall										hero.jumpSpeed = 0;					hasBeenJumping=false;				}							}			//jumping			if (hero.jumpSpeed != Infinity) 			{				isJumping=true;				//add gravity				hero.jumpSpeed += hero.gravity;				//hero cant move more then tilesize at any step				if (hero.jumpSpeed > ts) 				{					hero.jumpSpeed = ts;				} else if (hero.jumpSpeed < - ts) 				{					hero.jumpSpeed = -ts;				}				var moveOb:Object = new Object();				//manage movement				moveOb.dirx = 0;				moveOb.diry = 1;				moveOb.sprNum = hero.sprNum;				//hit the wall				if(getMyCorners(hero.x, hero.y + hero.jumpSpeed, hero) == true)				{					//free to move					moveObject (hero, moveOb, hero.jumpSpeed);				}else				{					//hit the wall					if (hero.jumpSpeed < 0) 					{						fallingDown=false;						//going up						hero.y = hero.ytile * ts;						//cant go up anymore, but probably will fall down						hero.jumpSpeed = 0;						moveObject (hero, moveOb, hero.jumpSpeed);					}else if (hero.jumpSpeed > 0) 					{						fallingDown=true;						//going down						hero.ytile = Math.floor((hero.y + hero.jumpSpeed) / ts);						hero.y = (hero.ytile + 1) * ts - hero.ts;						//stand on the wall						if (hasBeenJumping==true)						{							//BUGGGGGGGG							//trace(keys[Keyboard.LEFT].down);							keys[Keyboard.LEFT].down=false;							//trace(keys[Keyboard.LEFT].down);							keys[Keyboard.RIGHT].down=false;							hasBeenJumping=false;							onRightWall=false;							onLeftWall=false;							onWall=false;							fallingDown=false;						}												hero.jumpSpeed = Infinity;						moveObject (hero, moveOb, 0);						if (hero.sprNum==12)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=3;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;													}						else if (hero.sprNum==13)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=2;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}					}									}			}						//get the focus to the main clip to keys are detected			if (myParent.stage.focus != myParent) {				myParent.stage.focus = myParent;			}			if (keys[Keyboard.LEFT].down==true)			{				if (getMyCornersForJumpWall(hero.x + keyOb.dirx * hero.speed, hero.y, hero)==false && hasBeenJumping==false)				{					keys[Keyboard.LEFT].down=false;				}							}			if (keys[Keyboard.RIGHT].down==true)			{				if (getMyCornersForJumpWall(hero.x + keyOb.dirx * hero.speed, hero.y, hero)==false && hasBeenJumping==false)				{					keys[Keyboard.RIGHT].down=false;				}			}			if (keys[Keyboard.LEFT].down==true)			{				keys[Keyboard.RIGHT].down=false;			}			if (keys[Keyboard.RIGHT].down==true)			{				keys[Keyboard.LEFT].down=false;			}			if (onRightWall)			{				onLeftWall=false;							}			if (onLeftWall)			{				onRightWall=false;			}						//animate the objects				//animateSprite ();				if (keys[Keyboard.LEFT].down==true && hero.gravity>=1 && hero.jumpSpeed==Infinity)				{					if (getMyCorners(hero.x + keyOb.dirx * hero.speed, hero.y, hero) == true) 					{						var ob:Object = hero;						ob.anim=keys[Keyboard.LEFT].anim;						if(ob.anim.length > 0)						{							//add 1 to time counter							ob.animTime++;							var reachedEnd:Boolean = false;							//check if the time has counted up							if(ob.animTime == ob.anim[ob.animCount + 1])							{								//add to current image counter								ob.animCount += 2;								//check if end of animation is reached								if(ob.animCount == ob.anim.length)								{									//reset to start									ob.animCount = 0;								}								//check if its tile or separate object like hero								if(ob.bmp == null)								{									//clear the current tile image									var rect:Rectangle = new Rectangle(ob.xt * ts, ob.yt * ts, ts, ts);									tilesBmp.bitmapData.fillRect (rect, 0x00000000);									//change the image if time is right									ob.s = ob.anim[ob.animCount];									drawTile (ob.baseSpr, ob.xt, ob.yt);									drawTile (ob.s, ob.xt, ob.yt);									if (goingThroughPortal== true)									{										myParent.removeChild(ob.bmp);									}																	}else								{									//its hero									ob.sprNum = ob.anim[ob.animCount];									ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;								}								//reset animation timer								ob.animTime = 0;							}						}					}										else 					{						hero.sprNum=3;					}									}  if (keys[Keyboard.RIGHT].down==true && hero.gravity>=1 && hero.jumpSpeed==Infinity)				{										if (getMyCorners(hero.x + keyOb.dirx * hero.speed, hero.y, hero) == true) 					{						var ob:Object = hero;						ob.anim=keys[Keyboard.RIGHT].anim;						if(ob.anim.length > 0)						{							//add 1 to time counter							ob.animTime++;							var reachedEnd:Boolean = false;							//check if the time has counted up							if(ob.animTime == ob.anim[ob.animCount + 1])							{								//add to current image counter								ob.animCount += 2;								//check if end of animation is reached								if(ob.animCount == ob.anim.length)								{									//reset to start									ob.animCount = 0;								}								//check if its tile or separate object like hero								if(ob.bmp == null)								{									//clear the current tile image									var rect:Rectangle = new Rectangle(ob.xt * ts, ob.yt * ts, ts, ts);									tilesBmp.bitmapData.fillRect (rect, 0x00000000);									//change the image if time is right									ob.s = ob.anim[ob.animCount];									drawTile (ob.baseSpr, ob.xt, ob.yt);									drawTile (ob.s, ob.xt, ob.yt);									if (goingThroughPortal== true)									{										myParent.removeChild(ob.bmp);									}																	}else								{									//its hero									ob.sprNum = ob.anim[ob.animCount];									ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;								}								//reset animation timer								ob.animTime = 0;							}						}					}					else 					{						hero.sprNum=2;					}									} if(keys[Keyboard.RIGHT].down==true && hero.gravity!=1 && onWall==true)				{					if (ob!=null)					{						ob=hero;					}else					{						var ob:Object = hero;					}																	hero.sprNum=15;					ob.sprNum = hero.sprNum;					ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;				}				 if(keys[Keyboard.LEFT].down==true && hero.gravity!=1 && onWall==true)				{					if (ob!=null)					{						ob=hero;					}else					{						var ob:Object = hero;					}																	hero.sprNum=14;					ob.sprNum = hero.sprNum;					ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;				}								if (keys[Keyboard.RIGHT].down == false && keys[Keyboard.LEFT].down==false && keys[Keyboard.UP].down == false && keys[Keyboard.DOWN].down==false)				{					if (hero.sprNum == 0)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=0;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==4)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=0;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==8)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=0;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum == 1)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=1;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==5)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=1;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==9)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=1;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum == 2)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=2;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==6)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=2;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==10)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=2;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum == 3)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=3;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==7)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=3;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==11)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=3;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==14)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=3;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						else if (hero.sprNum==15)						{							if (ob!=null)							{								ob=hero;							}else							{								var ob:Object = hero;							}														hero.sprNum=2;							ob.sprNum = hero.sprNum;							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}				}										/*var moveOb:Object = new Object();						//find if any movement key is down			for each (var keyOb in keys) 			{				if(keyOb.down == false)				{						if (hero.sprNum == 0)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 0;							moveOb.anim = [];						}						else if (hero.sprNum==4)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 0;							moveOb.anim = [];						}						else if (hero.sprNum==8)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 0;							moveOb.anim = [];						}						else if (hero.sprNum == 1)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 1;							moveOb.anim = [];						}						else if (hero.sprNum==5)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 1;							moveOb.anim = [];						}						else if (hero.sprNum==9)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 1;							moveOb.anim = [];						}						else if (hero.sprNum == 2)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 2;							moveOb.anim = [];						}						else if (hero.sprNum==6)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 2;							moveOb.anim = [];						}						else if (hero.sprNum==10)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 2;							moveOb.anim = [];						}						else if (hero.sprNum == 3)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 3;							moveOb.anim = [];						}						else if (hero.sprNum==7)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 3;							moveOb.anim = [];						}						else if (hero.sprNum==11)						{							//keyOb==[Keyboard.DOWN];							moveOb.dirx = 0;							moveOb.diry = 0;							moveOb.sprNum = 3;							moveOb.anim = [];						}										}				//yep, arrow key is down				else if (keyOb.down == true && keyOb.dirx != 0) 				{					//check if tile is walkable					if (getMyCorners(hero.x + keyOb.dirx * hero.speed, hero.y, hero) == false) {						//we have hit the wall, place near it						if(keyOb.dirx < 0){							hero.x = hero.xtile * ts;					}else					{						//we have hit the wall, place near it						if(keyOb.dirx < 0)						{							hero.x = hero.xtile * ts;						}else //if(keyOb.dirx > 0)						{							hero.xtile = Math.floor((hero.x + hero.speed) / ts);							hero.x = (hero.xtile + 1) * ts - hero.ts;						}					moveObject (hero, {dirx:0, diry:0, sprNum:keyOb.sprNum});					}else						{							moveObject (hero, keyOb);						}						break;					}				}				//currently not jumping			if (hero.jumpSpeed == Infinity) {				//jump started				if (keys[Keyboard.UP].down == true) {					hero.jumpSpeed = hero.jumpStart;				} else if (getMyCorners(hero.x, hero.y + 1, hero) == true) {					//if both tiles below are walkable, we will fall					hero.jumpSpeed = 0;				}			}			//jumping			if (hero.jumpSpeed != Infinity) {				//add gravity				hero.jumpSpeed += hero.gravity;				//hero cant move more then tilesize at any step				if (hero.jumpSpeed > ts) {					hero.jumpSpeed = ts;				} else if (hero.jumpSpeed < - ts) {					hero.jumpSpeed = -ts;				}				var moveOb:Object = new Object();				//manage movement				moveOb.dirx = 0;				moveOb.diry = 1;				moveOb.sprNum = hero.sprNum;				//hit the wall				if(getMyCorners(hero.x, hero.y + hero.jumpSpeed, hero) == true){					//free to move					moveObject (hero, moveOb, hero.jumpSpeed);				}else{					//hit the wall					if (hero.jumpSpeed < 0) {						//going up						hero.y = hero.ytile * ts;						//cant go up anymore, but probably will fall down						hero.jumpSpeed = 0;						moveObject (hero, moveOb, hero.jumpSpeed);					}else if (hero.jumpSpeed > 0) {						//going down						hero.ytile = Math.floor((hero.y + hero.jumpSpeed) / ts);						hero.y = (hero.ytile + 1) * ts - hero.ts;						//stand on the wall						hero.jumpSpeed = Infinity;						moveObject (hero, moveOb, 0);					}				}			}			//get the focus to the main clip to keys are detected			/*if (myParent.stage.focus != myParent) {				myParent.stage.focus = myParent;			}*/																						/*}else if(keyOb.diry < 0)						{							hero.y = hero.ytile * ts;						}else if(keyOb.diry > 0)						{							hero.ytile = Math.floor((hero.y + hero.speed) / ts);							hero.y = (hero.ytile + 1) * ts - hero.ts;						}						moveOb.dirx = 0;						moveOb.diry = 0;						moveOb.sprNum = keyOb.sprNum;						moveOb.anim = [];						//try to move hero around the wall tiles						if(keyOb.dirx != 0)						{							var ytc:int = Math.floor((hero.y + hero.ts/2) / ts);							if(isWalkable(hero.xtile + keyOb.dirx, ytc)){								//align vertically								var centerY:int = ytc * ts + (ts - hero.ts) / 2;								if(hero.y > centerY)								{									//move up									hero.y--;									moveOb.anim = keyOb.anim;								}else if(hero.y < centerY)								{									//move down									hero.y++;									moveOb.anim = keyOb.anim;								}							}						}else						{							var xtc:int = Math.floor((hero.x + hero.ts/2) / ts);							if(isWalkable(xtc, hero.ytile + keyOb.diry))							{								//align horisontal								var centerX:int = xtc * ts + (ts - hero.ts) / 2;								if(hero.x > centerX)								{									//move left									hero.x--;									moveOb.anim = keyOb.anim;								}else if(hero.x < centerX)								{									hero.x++;									moveOb.anim = keyOb.anim;								}							}						}					}					break;				}							}			if(moveOb.dirx != null)			{				//move the hero				moveObject (hero, moveOb);			}else			{				hero.anim = [];			}			//animate the objects				animateSprite ();			//get the focus to the main clip to keys are detected			if (myParent.stage.focus != myParent) 			{				myParent.stage.focus = myParent;			}						if(isTeleporter(hero.xtile, hero.ytile))			   {				  cleanUp();				 myParent.level2Available=true;				  myParent.gotoAndStop("levelselect");			   }*/			   						//myParent.scrollRect = view;						//view.x = hero.x - stageW2;  						//view.y = hero.y - stageH2;			if(isDoor(hero.xtile, hero.ytile))			   {				  cleanUp();				 myParent.knightLevel5Available=true;				  myParent.gotoAndStop("knightlevelselect");			   }			if(isSpike(hero.xtile, hero.ytile))			{				trace("is spike");				if (hero.mymap==0)				{					trace("mymap=0");					youDied();																			}				else if (hero.mymap==1)				{					youDied2();				}				else if (hero.mymap==2)				{					youDiedFinal();				}			}  								}		private function youAreDyingFinal(e:Event)		{			if (hero.bmp.y >= 576)			{				myParent.removeChild(tilesBmp);				myParent.removeChild(hero.bmp);				myParent.removeEventListener (Event.ENTER_FRAME, youAreDyingFinal);				bgMusicState=false;				playBgMusic();				myParent.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);				myParent.gotoAndStop("youloseknight");			}			else			{				hero.bmp.y+=4;				hero.bmp.x=hero.bmp.x;							}		}		private function youAreDying(e:Event)		{			if (hero.bmp.y >= 576)			{				myParent.removeEventListener (Event.ENTER_FRAME, youAreDying);				hero.mymap = 1;				hero.xtile = 1;				hero.ytile =16;									animatedObjects.splice(1,animatedObjects.length-1);									buildMap();				myParent.addEventListener (KeyboardEvent.KEY_DOWN, downKeys);				myParent.addEventListener (KeyboardEvent.KEY_UP, upKeys);				myParent.addEventListener (Event.ENTER_FRAME, runGame);											}/*else if (heroFallenUp==false)			{				hero.bmp.y-=6;				if (hero.y<=heroMaxY)				{					heroFallenUp=true;				}			}						else if (heroFallenUp==true)			{				hero.bmp.y+=4;				hero.bmp.x=hero.bmp.x;							}*/			else			{				hero.bmp.y+=4;				hero.bmp.x=hero.bmp.x;			}					}		private function youDied()		{			myParent.removeEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.removeEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.removeEventListener (Event.ENTER_FRAME, runGame);						heroMaxY=hero.y-16;			trace(heroMaxY);			heroFallenUp=false;			hero.bmp.y-=8;			hero.bmp.x=hero.bmp.x;			myParent.addEventListener (Event.ENTER_FRAME, youAreDying);											}		private function youAreDying2(e:Event)		{			if (hero.bmp.y >= 576)			{				myParent.removeEventListener (Event.ENTER_FRAME, youAreDying2);				hero.mymap = 2;				hero.xtile = 1;				hero.ytile = 16;									animatedObjects.splice(1,animatedObjects.length-1);									buildMap();				myParent.addEventListener (KeyboardEvent.KEY_DOWN, downKeys);				myParent.addEventListener (KeyboardEvent.KEY_UP, upKeys);				myParent.addEventListener (Event.ENTER_FRAME, runGame);											}			else			{				hero.bmp.y+=4;				hero.bmp.x=hero.bmp.x;							}		}		private function youDied2()		{			myParent.removeEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.removeEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.removeEventListener (Event.ENTER_FRAME, runGame);									hero.bmp.y-=8;			hero.bmp.x=hero.bmp.x;			myParent.addEventListener (Event.ENTER_FRAME, youAreDying2);											}		private function youDiedFinal()		{			myParent.removeEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.removeEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.removeEventListener (Event.ENTER_FRAME, runGame);			myParent.addEventListener (Event.ENTER_FRAME, youAreDyingFinal);			hero.bmp.y-=8;			hero.bmp.x=hero.bmp.x;			if (hero.bmp.y > myParent.height)			{				myParent.removeChild(tilesBmp);				myParent.removeChild(hero.bmp);				myParent.gotoAndStop("knightlevelselect");			}								}				private function cleanUp()		{			myParent.removeEventListener (KeyboardEvent.KEY_DOWN, downKeys);			myParent.removeEventListener (KeyboardEvent.KEY_UP, upKeys);			myParent.removeEventListener (Event.ENTER_FRAME, runGame);			bgMusicState=false;			playBgMusic();			myParent.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			myParent.removeChild(tilesBmp);			myParent.removeChild(hero.bmp);		}		private function isTeleporter (xt:int, yt:int):Boolean 		{			if(currentMap[yt][xt] == 106)			{				return true;			}else			{				return false;			}					}				//this function will finds if tile is walkable		private function isWalkable (xt:int, yt:int):Boolean 		{			if(currentMap[yt][xt] >= 100)			{				return true;			}else			{				return false;			}		}		//this function will finds if tile is ladder		private function isLadder (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt];			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "ladder")				{					return true;				}			}			return false;		}		private function isJumpWallForCorners (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt];			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "jumpWall")				{					return true;				}			}			return false;		}		private function isSpike (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt];			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "spike")				{					return true;				}			}			return false;		}		private function isDoor (xt:int, yt:int):Boolean 		{			var s:int = currentMap[yt][xt];			if(complexTiles[s] != null)			{				if(complexTiles[s].specialType == "DOOR")				{					return true;				}			}			return false;		}		private function isJumpWall (xt:int, yt:int):Boolean 		{			var tileToRight:int = currentMap[yt][xt+1];			var tileToLeft:int = currentMap [yt][xt-1];						if(complexTiles[tileToRight] != null && complexTiles[tileToLeft] != null)			{				if(complexTiles[tileToRight].specialType == "jumpWall")				{					return true;				}				else if (complexTiles[tileToLeft].specialType == "jumpWall")				{					return true;				}				else 				{					return false;				}			}			return false;		}		//this function will detect keys that are being pressed		private function downKeys (ev:KeyboardEvent):void 		{			//check if the is arrow key			if (keys[ev.keyCode] != undefined) 			{				//set the key to true				keys[ev.keyCode].down = true;			}		}		//this function will detect keys that are being released		private function upKeys (ev:KeyboardEvent):void 		{			//check if the is arrow key			if (keys[ev.keyCode] != undefined) 			{				//set the key to false				keys[ev.keyCode].down = false;							}		}		//this function will move object		private function moveObject (ob:*, moveOb:* = null, speed:Number = Infinity):void {			if(speed == Infinity)			{				speed = ob.speed;			}			if(moveOb != null)			{				ob.x += moveOb.dirx * speed;//ob.speed;				ob.y += moveOb.diry * speed;//ob.speed;				//check if graphics need to change				if (ob.moveOb != moveOb) 				{					//change sprite					ob.moveOb = moveOb;					ob.sprNum = moveOb.sprNum;					ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;					/*if(ob.anim != moveOb.anim)					{						ob.animTime = 0;						ob.animCount = 0;						ob.anim = moveOb.anim;					}*/				}			}else			{				//find new coordinates				ob.x = ob.xtile * ts + (ts - ob.ts) / 2;				ob.y = (ob.ytile + 1) * ts - ob.ts;			}			//update tile			ob.xtile = Math.floor(ob.x / ts);			ob.ytile = Math.floor(ob.y / ts);			//center tile			ob.ytc = Math.floor((ob.y + ob.ts/2) / ts);			ob.xtc = Math.floor((ob.x + ob.ts/2) / ts);			//place the graphics			ob.bmp.x = ob.x;			ob.bmp.y = ob.y;			checkDoor (ob);		}		//this function will check for door		private function checkDoor (ob:*):void 		{			//center tile			var ytc:int = Math.floor((ob.y + ob.ts/2) / ts);			var xtc:int = Math.floor((ob.x + ob.ts/2) / ts);			var tileName:String = ob.mymap + "_" + xtc + "_" + ytc;			//check if door exist			if (doors[tileName] != null) 			{				//change map													ob.mymap = doors[tileName][0];					ob.xtile = doors[tileName][1];					ob.ytile = doors[tileName][2];										animatedObjects.splice(1,animatedObjects.length-1);					buildMap();																									}		}		private function getMyCorners (x:Number, y:Number, ob:Object):Boolean 		{			//find corner points			var upY:Number = Math.floor(y / ts);			var downY:Number = Math.floor((y + ob.ts - 1) / ts);			var leftX:Number = Math.floor(x / ts);			var rightX:Number = Math.floor((x + ob.ts - 1) / ts);			if (upY < 0 || downY >= mapH || leftX < 0 || rightX >= mapW) 			{				return false;			}			//check if they are walls			var ul:Boolean = isWalkable (leftX, upY);			var dl:Boolean = isWalkable (leftX, downY);			var ur:Boolean = isWalkable (rightX, upY);			var dr:Boolean = isWalkable (rightX, downY);			//check for cloud			if(y > ob.y)			{				if(isCloud (leftX, downY) || isCloud (rightX, downY))				{					return false;				}			}			if(x > ob.x || x<ob.x)			{				if(isJumpWall (leftX, downY) || isJumpWall (rightX, downY))				{					return false;				}			}			return ul && dl && ur && dr;		}		private function getMyCornersForJumpWall (x:Number, y:Number, ob:Object):Boolean 		{			//find corner points			var upY:Number = Math.floor(y / ts);			var downY:Number = Math.floor((y + ob.ts - 1) / ts);			var leftX:Number = Math.floor(x / ts);			var rightX:Number = Math.floor((x + ob.ts - 1) / ts);			if (upY < 0 || downY >= mapH || leftX < 0 || rightX >= mapW) 			{				return false;			}			//check if they are walls			var ul:Boolean = isJumpWallForCorners (leftX, upY);					var dl:Boolean = isJumpWallForCorners (leftX, downY);						var ur:Boolean = isJumpWallForCorners (rightX, upY);			var dr:Boolean = isJumpWallForCorners (rightX, downY);			if (dr==false && ur==true)			{				return false;			}			else if (dl==false&&ul==true)			{				return false;			}			else 			{				return true;			}										//check for cloud			/*if(y > ob.y)			{				if(isCloud (leftX, downY) || isCloud (rightX, downY))				{					return false;				}			}			if(x > ob.x || x<ob.x)			{				if(isJumpWall (leftX, downY) || isJumpWall (rightX, downY))				{					return false;				}			}*/								}		//this function will animate all the objects		private function animateSprite ():void 		{			//run through all objects needing the animation			for (var n:int = 0; n < animatedObjects.length; n++) 			{				var ob:Object = animatedObjects[n];				if(ob.anim.length > 0)				{					//add 1 to time counter					ob.animTime++;					var reachedEnd:Boolean = false;					//check if the time has counted up					if(ob.animTime == ob.anim[ob.animCount + 1])					{						//add to current image counter						ob.animCount += 2;						//check if end of animation is reached						if(ob.animCount == ob.anim.length)						{							//reset to start							ob.animCount = 0;						}						//check if its tile or separate object like hero						if(ob.bmp == null)						{							//clear the current tile image							var rect:Rectangle = new Rectangle(ob.xt * ts, ob.yt * ts, ts, ts);							tilesBmp.bitmapData.fillRect (rect, 0x00000000);							//change the image if time is right							ob.s = ob.anim[ob.animCount];							drawTile (ob.baseSpr, ob.xt, ob.yt);							drawTile (ob.s, ob.xt, ob.yt);							if (goingThroughPortal== true)							{								myParent.removeChild(ob.bmp);							}													}else						{							//its hero							ob.sprNum = ob.anim[ob.animCount];							ob.bmp.bitmapData = getImageFromSheet (ob.sprNum, ob).bitmapData;						}						//reset animation timer						ob.animTime = 0;					}				}			}		}		//this function gets image from tilesheet		private function getImageFromSheet (s:Number, ob:* = null):Bitmap 		{			var tsize:int = ts;			var sheet:BitmapData = tSheet;			if(ob != null)			{				tsize = ob.ts;				sheet = ob.sheet;			}			//number of columns in tilesheet			var sheetColumns:int = tSheet.width / tsize;			//position where to take graphics from			var col:int = s % sheetColumns;			var row:int = Math.floor(s / sheetColumns);			//rectangle that defines tile graphics			var rect:Rectangle = new Rectangle(col * tsize, row * tsize, tsize, tsize);			var pt:Point = new Point(0, 0);			//get the tile graphics from tilesheet			var bmp:Bitmap =  new Bitmap(new BitmapData(tsize, tsize, true, 0));			bmp.bitmapData.copyPixels (sheet, rect, pt, null, null, true);			return bmp;		}		private function drawTile (s:Number, xt:int, yt:int):void 		{			var bmp:Bitmap = getImageFromSheet (s);			//rectangle has size of tile and it starts from 0,0			var rect:Rectangle = new Rectangle(0, 0, ts, ts);			//point on screen where the tile goes			var pt:Point = new Point(xt * ts, yt * ts);			//copy tile bitmap to main bitmap			tilesBmp.bitmapData.copyPixels (bmp.bitmapData, rect, pt, null, null, true);		}		private function createComplexTile (spr1:int, animArr:Array, st:String = ""):Object		{			//create new object			var ob:Object = new Object();			//base graphics, will always remain same			ob.baseSpr = spr1;			//array of animation graphics			ob.anim = animArr;			//tile could be some special type			ob.specialType = st;			return ob;		}	}}